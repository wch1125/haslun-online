/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPACE CAPITAL - SHIP TELEMETRY SYSTEM
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Derived metrics from 45-minute CSV candle data.
 * These metrics drive ship behavior, animation, and personality.
 * 
 * Raw Data → Metrics → Traits → Ship Behavior → UI Feedback
 * 
 * The UI never needs to know a candle existed.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 */

window.ShipTelemetry = (function() {
  'use strict';

  // ═══════════════════════════════════════════════════════════════════════════
  // RAW METRICS (Derived from 45-min CSV parsing)
  // ═══════════════════════════════════════════════════════════════════════════
  
  // These would be generated by a Node/Python build script from CSV files
  // Values normalized to 0-1 scale where applicable
  
  const RAW_METRICS = {
    ACHR: {
      volatility: 0.0157,
      avgReturn: 0.00013,
      maxDrawdown: -0.528,
      trendStrength: 0.13,
      chopRatio: 117.1,
      signalClarity: 0.34,
      volumeStability: 1.06
    },
    RKLB: {
      volatility: 0.0151,
      avgReturn: 0.00062,
      maxDrawdown: -0.515,
      trendStrength: 3.39,
      chopRatio: 24.3,
      signalClarity: 0.31,
      volumeStability: 0.95
    },
    // Estimated metrics for other tickers based on observed behavior
    LUNR: {
      volatility: 0.0189,
      avgReturn: 0.00045,
      maxDrawdown: -0.62,
      trendStrength: 1.8,
      chopRatio: 45.2,
      signalClarity: 0.28,
      volumeStability: 0.78
    },
    JOBY: {
      volatility: 0.0142,
      avgReturn: 0.00028,
      maxDrawdown: -0.48,
      trendStrength: 0.95,
      chopRatio: 68.4,
      signalClarity: 0.42,
      volumeStability: 0.88
    },
    ASTS: {
      volatility: 0.0198,
      avgReturn: 0.00089,
      maxDrawdown: -0.71,
      trendStrength: 2.1,
      chopRatio: 52.8,
      signalClarity: 0.25,
      volumeStability: 0.72
    },
    BKSY: {
      volatility: 0.0134,
      avgReturn: 0.00018,
      maxDrawdown: -0.45,
      trendStrength: 0.82,
      chopRatio: 89.3,
      signalClarity: 0.38,
      volumeStability: 0.91
    },
    GME: {
      volatility: 0.0312,
      avgReturn: 0.00142,
      maxDrawdown: -0.83,
      trendStrength: 1.2,
      chopRatio: 156.8,
      signalClarity: 0.18,
      volumeStability: 0.45
    },
    EVEX: {
      volatility: 0.0125,
      avgReturn: 0.00022,
      maxDrawdown: -0.38,
      trendStrength: 0.75,
      chopRatio: 72.1,
      signalClarity: 0.45,
      volumeStability: 0.94
    },
    RDW: {
      volatility: 0.0118,
      avgReturn: 0.00015,
      maxDrawdown: -0.42,
      trendStrength: 0.68,
      chopRatio: 85.4,
      signalClarity: 0.41,
      volumeStability: 0.96
    },
    PL: {
      volatility: 0.0165,
      avgReturn: 0.00035,
      maxDrawdown: -0.55,
      trendStrength: 1.45,
      chopRatio: 58.2,
      signalClarity: 0.35,
      volumeStability: 0.82
    },
    KTOS: {
      volatility: 0.0128,
      avgReturn: 0.00048,
      maxDrawdown: -0.35,
      trendStrength: 2.8,
      chopRatio: 32.5,
      signalClarity: 0.52,
      volumeStability: 0.89
    },
    LHX: {
      volatility: 0.0098,
      avgReturn: 0.00032,
      maxDrawdown: -0.28,
      trendStrength: 2.2,
      chopRatio: 28.4,
      signalClarity: 0.58,
      volumeStability: 0.97
    },
    RTX: {
      volatility: 0.0085,
      avgReturn: 0.00028,
      maxDrawdown: -0.22,
      trendStrength: 2.5,
      chopRatio: 22.8,
      signalClarity: 0.62,
      volumeStability: 0.98
    },
    GE: {
      volatility: 0.0092,
      avgReturn: 0.00038,
      maxDrawdown: -0.25,
      trendStrength: 2.9,
      chopRatio: 19.5,
      signalClarity: 0.65,
      volumeStability: 0.96
    },
    COHR: {
      volatility: 0.0145,
      avgReturn: 0.00055,
      maxDrawdown: -0.48,
      trendStrength: 1.9,
      chopRatio: 48.2,
      signalClarity: 0.44,
      volumeStability: 0.85
    },
    XAR: {
      volatility: 0.0078,
      avgReturn: 0.00025,
      maxDrawdown: -0.18,
      trendStrength: 3.2,
      chopRatio: 15.2,
      signalClarity: 0.72,
      volumeStability: 0.99
    }
  };

  // ═══════════════════════════════════════════════════════════════════════════
  // NORMALIZATION RANGES (for converting raw → 0-1 scale)
  // ═══════════════════════════════════════════════════════════════════════════
  
  /**
   * RANGES define GAMEPLAY SCALING BOUNDS, not statistical extrema.
   * These are design tuning knobs that affect fleet feel globally.
   * 
   * Adjust carefully:
   * - Widening ranges → more ships cluster toward middle
   * - Narrowing ranges → more ships hit extremes
   * - These should reflect desired PLAYER PERCEPTION, not market reality
   */
  const RANGES = {
    volatility: { min: 0.005, max: 0.035 },
    trendStrength: { min: 0, max: 4 },
    chopRatio: { min: 10, max: 200 },
    signalClarity: { min: 0.1, max: 0.8 },
    volumeStability: { min: 0.4, max: 1.1 },
    maxDrawdown: { min: -0.9, max: -0.1 }
  };

  function normalize(value, min, max) {
    return Math.max(0, Math.min(1, (value - min) / (max - min)));
  }

  function invertNormalize(value, min, max) {
    return 1 - normalize(value, min, max);
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // DERIVED TELEMETRY (Game-ready metrics)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Convert raw metrics to game-ready telemetry
   */
  function deriveTelemetry(raw) {
    const r = RANGES;
    
    // Hull Resilience: inverse of max drawdown severity + recovery potential
    // Lower drawdown = higher resilience
    const hullResilience = invertNormalize(raw.maxDrawdown, r.maxDrawdown.min, r.maxDrawdown.max);
    
    // Thrust Potential: trend strength normalized
    // Higher trend = stronger engines
    const thrustPotential = normalize(raw.trendStrength, r.trendStrength.min, r.trendStrength.max);
    
    // Maneuver Stability: inverse of chop ratio
    // Lower chop = more stable movement
    const maneuverStability = invertNormalize(raw.chopRatio, r.chopRatio.min, r.chopRatio.max);
    
    // Signal Clarity: direct mapping
    const signalClarity = normalize(raw.signalClarity, r.signalClarity.min, r.signalClarity.max);
    
    // Chop Sensitivity: normalized chop ratio
    // Higher = more jittery/reactive
    const chopSensitivity = normalize(raw.chopRatio, r.chopRatio.min, r.chopRatio.max);
    
    // Volume Reliability: direct mapping
    const volumeReliability = normalize(raw.volumeStability, r.volumeStability.min, r.volumeStability.max);
    
    // Volatility Factor: normalized volatility
    const volatilityFactor = normalize(raw.volatility, r.volatility.min, r.volatility.max);
    
    // Regime Bias: determined by trend vs chop balance
    let regimeBias = 'neutral';
    if (thrustPotential > 0.6 && maneuverStability > 0.5) {
      regimeBias = 'trend';
    } else if (chopSensitivity > 0.7) {
      regimeBias = 'chaotic';
    } else if (maneuverStability > 0.6 && thrustPotential < 0.4) {
      regimeBias = 'range';
    }
    
    return {
      // Core behavioral metrics (0-1 scale)
      hullResilience: Math.round(hullResilience * 100) / 100,
      thrustPotential: Math.round(thrustPotential * 100) / 100,
      maneuverStability: Math.round(maneuverStability * 100) / 100,
      signalClarity: Math.round(signalClarity * 100) / 100,
      chopSensitivity: Math.round(chopSensitivity * 100) / 100,
      volumeReliability: Math.round(volumeReliability * 100) / 100,
      volatilityFactor: Math.round(volatilityFactor * 100) / 100,
      
      // Regime classification
      regimeBias,
      
      // Raw values for reference
      _raw: raw
    };
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // CACHED TELEMETRY MAP
  // ═══════════════════════════════════════════════════════════════════════════

  const TELEMETRY = {};
  
  // Pre-compute telemetry for all tickers
  for (const [ticker, raw] of Object.entries(RAW_METRICS)) {
    TELEMETRY[ticker] = deriveTelemetry(raw);
  }

  // Default telemetry for unknown tickers
  const DEFAULT_TELEMETRY = {
    hullResilience: 0.5,
    thrustPotential: 0.5,
    maneuverStability: 0.5,
    signalClarity: 0.5,
    chopSensitivity: 0.5,
    volumeReliability: 0.5,
    volatilityFactor: 0.5,
    regimeBias: 'neutral',
    _raw: null
  };

  // ═══════════════════════════════════════════════════════════════════════════
  // BEHAVIORAL MODIFIERS (Telemetry → Animation Parameters)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Get animation modifiers based on telemetry
   * These directly influence ship-behavior.js parameters
   */
  function getAnimationModifiers(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    return {
      // Idle animation speed (higher chop = faster jitter)
      idleSpeed: 0.5 + (t.chopSensitivity * 0.8),
      
      // Idle amplitude (higher chop = larger movements)
      idleAmplitude: 1 + (t.chopSensitivity * 3),
      
      // Thrust intensity (higher trend strength = stronger forward motion)
      thrustIntensity: 0.3 + (t.thrustPotential * 0.7),
      
      // Recovery speed (higher resilience = faster recovery from damage states)
      recoverySpeed: 0.5 + (t.hullResilience * 0.5),
      
      // Signal flicker rate (lower clarity = more flickering)
      signalFlicker: 1 - t.signalClarity,
      
      // Engine stability (affects exhaust particle consistency)
      engineStability: t.volumeReliability,
      
      // Overall volatility influence
      volatilityInfluence: t.volatilityFactor
    };
  }

  /**
   * Get behavioral state recommendations
   */
  function getBehaviorRecommendations(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    const recommendations = [];
    
    // Hull-based recommendations
    if (t.hullResilience < 0.35) {
      recommendations.push('fragile');
    } else if (t.hullResilience > 0.7) {
      recommendations.push('reinforced');
    }
    
    // Thrust-based recommendations
    if (t.thrustPotential > 0.7) {
      recommendations.push('momentum-capable');
    } else if (t.thrustPotential < 0.3) {
      recommendations.push('underpowered');
    }
    
    // Stability-based recommendations
    if (t.maneuverStability < 0.3) {
      recommendations.push('unstable');
    } else if (t.maneuverStability > 0.7) {
      recommendations.push('steady');
    }
    
    // Signal-based recommendations
    if (t.signalClarity < 0.3) {
      recommendations.push('nebulous');
    } else if (t.signalClarity > 0.7) {
      recommendations.push('clear-signal');
    }
    
    // Regime-based
    recommendations.push(t.regimeBias);
    
    return recommendations;
  }

  /**
   * Get suggested ship class based on telemetry
   */
  function getSuggestedClass(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    // Flagship: high trend strength + stability
    if (t.thrustPotential > 0.7 && t.maneuverStability > 0.6) {
      return 'Flagship';
    }
    
    // Moonshot: high volatility + chaos
    if (t.volatilityFactor > 0.7 && t.chopSensitivity > 0.6) {
      return 'Moonshot';
    }
    
    // Drone: high chop sensitivity, lower stability
    if (t.chopSensitivity > 0.7 && t.maneuverStability < 0.4) {
      return 'Drone';
    }
    
    // Scout: high signal clarity, moderate mobility
    if (t.signalClarity > 0.6 && t.maneuverStability > 0.5) {
      return 'Scout';
    }
    
    // Carrier: high stability, lower thrust
    if (t.maneuverStability > 0.7 && t.thrustPotential < 0.5) {
      return 'Carrier';
    }
    
    // Fighter: moderate-high thrust, moderate chop
    if (t.thrustPotential > 0.5 && t.chopSensitivity > 0.4 && t.chopSensitivity < 0.7) {
      return 'Fighter';
    }
    
    // Cargo: high volume reliability, low volatility
    if (t.volumeReliability > 0.8 && t.volatilityFactor < 0.3) {
      return 'Cargo';
    }
    
    // Default
    return 'Ship';
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // STATUS DESCRIPTORS (For UI)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Get human-readable status based on telemetry
   */
  function getStatusDescriptor(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    const recommendations = getBehaviorRecommendations(ticker);
    
    // Primary status
    let primary = 'Operational';
    if (recommendations.includes('fragile') && recommendations.includes('unstable')) {
      primary = 'Compromised';
    } else if (recommendations.includes('nebulous')) {
      primary = 'Nebulous';
    } else if (recommendations.includes('momentum-capable') && recommendations.includes('steady')) {
      primary = 'Combat Ready';
    } else if (recommendations.includes('reinforced')) {
      primary = 'Fortified';
    }
    
    // Regime status
    let regime = 'Standard Operations';
    switch (t.regimeBias) {
      case 'trend':
        regime = 'Trending Formation';
        break;
      case 'chaotic':
        regime = 'High Volatility Zone';
        break;
      case 'range':
        regime = 'Consolidation Pattern';
        break;
    }
    
    return { primary, regime, recommendations };
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // LIVERY SUGGESTIONS (Data → Paint Bay hints)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Get suggested livery mood based on telemetry
   */
  function getLiverySuggestion(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    // High trend strength = command/prestige liveries
    if (t.thrustPotential > 0.7 && t.maneuverStability > 0.6) {
      return {
        mood: 'commanding',
        suggestedPresets: ['livery_phosphor_green', 'livery_midnight_oil'],
        saturation: 'high',
        contrast: 'high'
      };
    }
    
    // Chaotic regime = fractured/aggressive
    if (t.regimeBias === 'chaotic') {
      return {
        mood: 'volatile',
        suggestedPresets: ['livery_solar_flare', 'livery_crimson_tide'],
        saturation: 'high',
        contrast: 'extreme'
      };
    }
    
    // Low signal clarity = muted/mysterious
    if (t.signalClarity < 0.3) {
      return {
        mood: 'nebulous',
        suggestedPresets: ['livery_void_walker', 'livery_nebula_drift'],
        saturation: 'low',
        contrast: 'low'
      };
    }
    
    // High stability, low volatility = calm/professional
    if (t.maneuverStability > 0.7 && t.volatilityFactor < 0.3) {
      return {
        mood: 'stable',
        suggestedPresets: ['livery_arctic_ghost', 'livery_midnight_oil'],
        saturation: 'moderate',
        contrast: 'moderate'
      };
    }
    
    // Default
    return {
      mood: 'neutral',
      suggestedPresets: ['livery_phosphor_green'],
      saturation: 'moderate',
      contrast: 'moderate'
    };
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // MISSION AFFINITY (Data → Mission recommendations)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Get mission type affinities based on telemetry
   */
  function getMissionAffinities(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    return {
      // Trend-following missions
      momentum: Math.round(t.thrustPotential * 100),
      
      // Volatility/scalping missions
      skirmish: Math.round((t.chopSensitivity + t.volatilityFactor) * 50),
      
      // Long-hold missions
      expedition: Math.round((t.hullResilience + t.maneuverStability) * 50),
      
      // Recon/intel missions
      reconnaissance: Math.round(t.signalClarity * 100),
      
      // Support/stability missions
      support: Math.round((t.volumeReliability + (1 - t.volatilityFactor)) * 50)
    };
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // RUNTIME TELEMETRY OVERLAYS
  // ═══════════════════════════════════════════════════════════════════════════
  
  /**
   * Runtime overlays allow missions/events to affect ship behavior
   * WITHOUT corrupting the historical identity stored in TELEMETRY.
   * 
   * These are transient modifiers that stack on top of base telemetry.
   */
  const runtimeOverlays = new Map();

  function setRuntimeOverlay(ticker, overlay) {
    runtimeOverlays.set(ticker, {
      ...runtimeOverlays.get(ticker),
      ...overlay,
      _timestamp: Date.now()
    });
  }

  function clearRuntimeOverlay(ticker) {
    runtimeOverlays.delete(ticker);
  }

  function getRuntimeOverlay(ticker) {
    return runtimeOverlays.get(ticker) || null;
  }

  /**
   * Get effective telemetry (base + runtime overlay)
   */
  function getEffectiveTelemetry(ticker) {
    const base = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    const overlay = runtimeOverlays.get(ticker);
    
    if (!overlay) return base;
    
    // Apply multiplicative modifiers
    return {
      ...base,
      hullResilience: base.hullResilience * (overlay.hullModifier || 1),
      thrustPotential: base.thrustPotential * (overlay.thrustModifier || 1),
      chopSensitivity: Math.min(1, base.chopSensitivity * (overlay.stressMultiplier || 1)),
      signalClarity: base.signalClarity * (overlay.clarityModifier || 1),
      // Flags
      _hasOverlay: true,
      _missionFatigue: overlay.missionFatigue || 0,
      _recentShock: overlay.recentShock || false
    };
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // TEXTUAL DESCRIPTORS (Language that mirrors data, no numbers)
  // ═══════════════════════════════════════════════════════════════════════════
  
  /**
   * Get human-readable trait descriptions for tooltips/labels.
   * These explain telemetry through LANGUAGE, not statistics.
   */
  function getTraitDescriptors(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    const descriptors = {
      hull: getHullDescriptor(t),
      engine: getEngineDescriptor(t),
      stability: getStabilityDescriptor(t),
      signal: getSignalDescriptor(t),
      personality: getPersonalityDescriptor(t)
    };
    
    return descriptors;
  }

  function getHullDescriptor(t) {
    if (t.hullResilience > 0.7) {
      return {
        label: 'Battle-Hardened',
        tooltip: 'Historically resilient under drawdown. Recovers quickly from adverse conditions.',
        mood: 'confident'
      };
    } else if (t.hullResilience > 0.5) {
      return {
        label: 'Standard Hull',
        tooltip: 'Moderate stress tolerance. Performs reliably under normal conditions.',
        mood: 'neutral'
      };
    } else if (t.hullResilience > 0.3) {
      return {
        label: 'Stressed Frame',
        tooltip: 'Shows wear under pressure. Extended deployments not recommended.',
        mood: 'cautious'
      };
    } else {
      return {
        label: 'Fragile',
        tooltip: 'Structurally compromised. Handle with care. High risk of cascade failures.',
        mood: 'critical'
      };
    }
  }

  function getEngineDescriptor(t) {
    if (t.thrustPotential > 0.7) {
      return {
        label: 'Momentum-Class',
        tooltip: 'Trend-following propulsion. Excels in sustained directional movement.',
        mood: 'aggressive'
      };
    } else if (t.thrustPotential > 0.4) {
      return {
        label: 'Standard Drive',
        tooltip: 'Balanced thrust output. Adaptable to varying conditions.',
        mood: 'neutral'
      };
    } else if (t.thrustPotential > 0.2) {
      return {
        label: 'Economy Drive',
        tooltip: 'Limited thrust capability. Best suited for short-range operations.',
        mood: 'cautious'
      };
    } else {
      return {
        label: 'Underpowered',
        tooltip: 'Weak directional bias. Often drifts without clear momentum.',
        mood: 'strained'
      };
    }
  }

  function getStabilityDescriptor(t) {
    if (t.maneuverStability > 0.7) {
      return {
        label: 'Rock Steady',
        tooltip: 'Exceptional stability. Minimal drift variance. Command-grade.',
        mood: 'confident'
      };
    } else if (t.maneuverStability > 0.5) {
      return {
        label: 'Stable',
        tooltip: 'Predictable movement patterns. Reliable for most operations.',
        mood: 'neutral'
      };
    } else if (t.maneuverStability > 0.3) {
      return {
        label: 'Erratic',
        tooltip: 'Prone to sudden movements. Requires active monitoring.',
        mood: 'cautious'
      };
    } else {
      return {
        label: 'Unstable',
        tooltip: 'High chop sensitivity. Expect unpredictable behavior.',
        mood: 'critical'
      };
    }
  }

  function getSignalDescriptor(t) {
    if (t.signalClarity > 0.6) {
      return {
        label: 'Crystal Clear',
        tooltip: 'Strong signal-to-noise ratio. Indicators are reliable.',
        mood: 'confident'
      };
    } else if (t.signalClarity > 0.4) {
      return {
        label: 'Readable',
        tooltip: 'Adequate signal quality. Some noise filtering required.',
        mood: 'neutral'
      };
    } else if (t.signalClarity > 0.25) {
      return {
        label: 'Noisy',
        tooltip: 'Degraded signal quality. False readings common.',
        mood: 'cautious'
      };
    } else {
      return {
        label: 'Nebulous',
        tooltip: 'Signal lost in noise. Operating on instruments only.',
        mood: 'critical'
      };
    }
  }

  function getPersonalityDescriptor(t) {
    // Combine traits into a personality summary
    if (t.regimeBias === 'trend' && t.thrustPotential > 0.6) {
      return {
        archetype: 'Trailblazer',
        summary: 'Built for sustained momentum. Thrives in trending markets.',
        fantasy: 'Command ship leading the fleet through charted territory.'
      };
    } else if (t.regimeBias === 'chaotic' && t.chopSensitivity > 0.6) {
      return {
        archetype: 'Wild Card',
        summary: 'Unpredictable but opportunistic. High risk, high potential.',
        fantasy: 'Volatile asset that could spike or crash without warning.'
      };
    } else if (t.maneuverStability > 0.7 && t.thrustPotential < 0.4) {
      return {
        archetype: 'Anchor',
        summary: 'Stable presence. Low excitement, high reliability.',
        fantasy: 'Support vessel providing fleet stability.'
      };
    } else if (t.signalClarity < 0.3) {
      return {
        archetype: 'Ghost',
        summary: 'Hard to read. Operates in fog. Trust your instincts.',
        fantasy: 'Reconnaissance unit in uncharted space.'
      };
    } else {
      return {
        archetype: 'Workhorse',
        summary: 'Balanced capabilities. Reliable under most conditions.',
        fantasy: 'Versatile craft suitable for varied missions.'
      };
    }
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // FLEET-LEVEL TELEMETRY (Emergent behavior from aggregation)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Compute fleet-wide telemetry metrics.
   * These drive hangar ambience, mission recommendations, and fleet mood.
   */
  function getFleetTelemetry(tickers) {
    // Default to all tickers if none specified
    if (!tickers || tickers.length === 0) {
      tickers = Object.keys(TELEMETRY);
    }
    
    const telemetries = tickers
      .map(t => TELEMETRY[t])
      .filter(Boolean);
    
    if (telemetries.length === 0) return null;
    
    const n = telemetries.length;
    
    // Averages
    const avgHull = telemetries.reduce((s, t) => s + t.hullResilience, 0) / n;
    const avgThrust = telemetries.reduce((s, t) => s + t.thrustPotential, 0) / n;
    const avgStability = telemetries.reduce((s, t) => s + t.maneuverStability, 0) / n;
    const avgChop = telemetries.reduce((s, t) => s + t.chopSensitivity, 0) / n;
    const avgSignal = telemetries.reduce((s, t) => s + t.signalClarity, 0) / n;
    
    // Variance (fleet coherence)
    const varianceChop = telemetries.reduce((s, t) => 
      s + Math.pow(t.chopSensitivity - avgChop, 2), 0) / n;
    const varianceThrust = telemetries.reduce((s, t) => 
      s + Math.pow(t.thrustPotential - avgThrust, 2), 0) / n;
    
    // Derived fleet metrics
    const fleetStability = 1 - Math.sqrt(varianceChop);
    const commandCoherence = avgThrust * avgStability * (1 - Math.sqrt(varianceThrust));
    
    // Risk posture
    let riskPosture = 'balanced';
    if (avgChop > 0.6 || avgHull < 0.4) {
      riskPosture = 'aggressive';
    } else if (avgStability > 0.7 && avgChop < 0.3) {
      riskPosture = 'conservative';
    }
    
    // Fleet mood
    let fleetMood = 'operational';
    if (commandCoherence > 0.5 && fleetStability > 0.7) {
      fleetMood = 'confident';
    } else if (avgHull < 0.35 || avgSignal < 0.3) {
      fleetMood = 'strained';
    } else if (avgChop > 0.6) {
      fleetMood = 'alert';
    }
    
    // Command ship identification (highest thrust + stability)
    let commandShip = null;
    let commandScore = 0;
    tickers.forEach(ticker => {
      const t = TELEMETRY[ticker];
      if (t) {
        const score = t.thrustPotential * t.maneuverStability;
        if (score > commandScore) {
          commandScore = score;
          commandShip = ticker;
        }
      }
    });
    
    return {
      // Core averages
      avgHull: Math.round(avgHull * 100) / 100,
      avgThrust: Math.round(avgThrust * 100) / 100,
      avgStability: Math.round(avgStability * 100) / 100,
      avgChop: Math.round(avgChop * 100) / 100,
      avgSignal: Math.round(avgSignal * 100) / 100,
      
      // Derived
      fleetStability: Math.round(fleetStability * 100) / 100,
      commandCoherence: Math.round(commandCoherence * 100) / 100,
      riskPosture,
      fleetMood,
      
      // Leadership
      commandShip,
      commandScore: Math.round(commandScore * 100) / 100,
      
      // Meta
      shipCount: n
    };
  }

  /**
   * Get fleet-level textual status
   */
  function getFleetStatus(tickers) {
    const fleet = getFleetTelemetry(tickers);
    if (!fleet) return null;
    
    let headline = 'Fleet Operational';
    let subtext = 'All systems nominal.';
    
    if (fleet.fleetMood === 'confident') {
      headline = 'Fleet Combat Ready';
      subtext = `${fleet.commandShip} commanding. High coherence detected.`;
    } else if (fleet.fleetMood === 'strained') {
      headline = 'Fleet Under Stress';
      subtext = 'Multiple systems showing wear. Consider rotation.';
    } else if (fleet.fleetMood === 'alert') {
      headline = 'Fleet on Alert';
      subtext = 'Elevated volatility across positions. Monitor closely.';
    }
    
    return {
      headline,
      subtext,
      mood: fleet.fleetMood,
      posture: fleet.riskPosture,
      commandShip: fleet.commandShip
    };
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // LIVERY MODULATION (Telemetry → Palette bias)
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Get palette generation bias based on telemetry.
   * These are NUDGES, not overrides - they influence generation.
   */
  function getPaletteBias(ticker) {
    const t = TELEMETRY[ticker] || DEFAULT_TELEMETRY;
    
    return {
      // Contrast: high chop → higher contrast (more visual separation)
      contrastBias: 0.5 + (t.chopSensitivity * 0.4),
      
      // Saturation: strong trend → higher saturation (confident colors)
      saturationBias: 0.6 + (t.thrustPotential * 0.3),
      
      // Warmth: volatile/chaotic → warmer (oranges, reds)
      // Stable → cooler (blues, greens)
      warmthBias: 0.5 + (t.chopSensitivity * 0.3) - (t.maneuverStability * 0.2),
      
      // Brightness: high signal clarity → brighter
      brightnessBias: 0.5 + (t.signalClarity * 0.3),
      
      // Complexity: chaotic regime → more accent colors
      complexityBias: t.regimeBias === 'chaotic' ? 0.8 : 
                      t.regimeBias === 'trend' ? 0.4 : 0.6,
      
      // Recommended hue families
      suggestedHues: getSuggestedHues(t)
    };
  }

  function getSuggestedHues(t) {
    const hues = [];
    
    // Trend-strong: command colors (greens, blues)
    if (t.thrustPotential > 0.6) {
      hues.push('green', 'teal', 'blue');
    }
    
    // Chaotic: warning/energy colors (oranges, reds)
    if (t.regimeBias === 'chaotic' || t.chopSensitivity > 0.6) {
      hues.push('orange', 'red', 'amber');
    }
    
    // Stable/carrier: cool professional (blue, gray, silver)
    if (t.maneuverStability > 0.7) {
      hues.push('blue', 'silver', 'cyan');
    }
    
    // Low signal: mysterious (purple, dark blue)
    if (t.signalClarity < 0.3) {
      hues.push('purple', 'indigo', 'void');
    }
    
    // Default
    if (hues.length === 0) {
      hues.push('green', 'blue', 'gray');
    }
    
    return [...new Set(hues)]; // Deduplicate
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // PUBLIC API
  // ═══════════════════════════════════════════════════════════════════════════

  console.log('[ShipTelemetry] Initialized with', Object.keys(TELEMETRY).length, 'ticker profiles');

  return {
    // Core data access (LOCKED CONTRACT)
    getTelemetry: (ticker) => TELEMETRY[ticker] || DEFAULT_TELEMETRY,
    getAllTelemetry: () => ({ ...TELEMETRY }),
    hasData: (ticker) => !!TELEMETRY[ticker],
    
    // Effective telemetry (with runtime overlays)
    getEffectiveTelemetry,
    
    // Runtime overlays
    setRuntimeOverlay,
    clearRuntimeOverlay,
    getRuntimeOverlay,
    
    // Behavioral parameters (LOCKED CONTRACT)
    getAnimationModifiers,
    getBehaviorRecommendations,
    getSuggestedClass,
    
    // UI descriptors (LOCKED CONTRACT)
    getStatusDescriptor,
    getTraitDescriptors,
    
    // Fleet-level (LOCKED CONTRACT)
    getFleetTelemetry,
    getFleetStatus,
    
    // Livery integration (LOCKED CONTRACT)
    getLiverySuggestion,
    getPaletteBias,
    
    // Mission integration (LOCKED CONTRACT)
    getMissionAffinities,
    
    // Raw access (for debugging only)
    _RAW_METRICS: RAW_METRICS,
    _TELEMETRY: TELEMETRY,
    _RANGES: RANGES
  };

})();
